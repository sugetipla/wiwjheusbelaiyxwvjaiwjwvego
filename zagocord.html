<!DOCTYPE html>
<html lang="ro">
<head>
    <meta charset="UTF-8">
    <title>ZAGOCORD V7 BEST ONE</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700;800;900&display=swap');
        * { margin: 0; padding: 0; box-sizing: border-box; }
        :root { --theme: #00bfff; --bg: #0f0f0f; --panel: #1a1a1a; }
        body { font-family: 'Poppins', sans-serif; background: var(--bg); color: #fff; height: 100vh; display: flex; justify-content: center; align-items: center; overflow: hidden; }
        #bg-canvas { position: fixed; top: 0; left: 0; z-index: -1; pointer-events: none; }
        
        .container { 
            width: 400px; max-height: 95vh; background: rgba(15,15,15,0.98); border: 1px solid var(--theme); 
            padding: 12px; display: flex; flex-direction: column; box-shadow: 0 0 30px #000; overflow: hidden;
        }
        h1 { text-align: center; font-size: 18px; font-weight: 900; color: var(--theme); margin-bottom: 2px; text-transform: uppercase; letter-spacing: 1px; }
        .version-text { text-align: center; font-size: 8px; color: var(--theme); margin-bottom: 6px; opacity: 0.8; letter-spacing: 2px; }

        .tabs { display: flex; gap: 1px; margin-bottom: 8px; border-bottom: 1px solid #333; padding-bottom: 4px; overflow-x: auto; }
        .tab { flex: 1; padding: 4px 6px; background: #222; font-size: 8px; font-weight: 700; cursor: pointer; text-align: center; border: 1px solid #333; color: #888; white-space: nowrap; min-width: 50px; }
        .tab.active { background: var(--theme); color: white; border-color: var(--theme); }

        .content { flex: 1; overflow-y: auto; padding-right: 2px; font-size: 10px; }
        .tab-content { display: none; } 
        .tab-content.active { display: block; }

        label { display: block; font-size: 8px; color: var(--theme); font-weight: 700; margin-top: 6px; text-transform: uppercase; }
        input[type="text"], input[type="password"], input[type="number"], input[type="file"], textarea, select { 
            width: 100%; background: #000; border: 1px solid #333; color: #fff; padding: 4px; font-size: 9px; margin-top: 2px; outline: none; 
        }
        input:focus, textarea:focus { border-color: var(--theme); }
        textarea { height: 45px; resize: vertical; }
        
        .grid-2 { display: grid; grid-template-columns: 1fr 1fr; gap: 4px; }
        
        button { width: 100%; padding: 6px; background: #222; color: #fff; border: 1px solid #444; cursor: pointer; font-size: 9px; font-weight: 700; margin-top: 4px; text-transform: uppercase; transition: 0.2s; }
        button:hover { background: #333; border-color: var(--theme); }
        .btn-main { background: var(--theme); border: none; color: #000; font-weight: 800; }
        .btn-main:hover { background: #0099cc; }
        .btn-destructive { background: #ff4757; border: none; color: white; }
        .btn-destructive:hover { background: #ff6b7a; }

        .checkbox-label { display: flex; align-items: center; gap: 6px; font-size: 9px; font-weight: 600; color: #ccc; background: #000; padding: 4px 6px; border: 1px solid #222; cursor: pointer; margin-top: 3px; }
        .checkbox-label input { width: auto; accent-color: var(--theme); margin: 0; }
        .percent-input { width: 40px !important; padding: 2px !important; height: 20px; text-align: center; margin: 0 !important; font-size: 8px !important; }

        .mode-selector { display: flex; gap: 3px; margin-top: 3px; }
        .mode-selector button { flex: 1; margin: 0; font-size: 8px; padding: 4px; }
        .mode-selector button.active { background: var(--theme); color: #000; }

        .progress-bar { width: 100%; height: 3px; background: #222; border-radius: 2px; margin-top: 6px; overflow: hidden; }
        .progress-fill { height: 100%; background: var(--theme); transition: width 0.2s; }
        .progress-text { text-align: center; font-size: 8px; margin-top: 2px; color: #888; }

        .color-preview { display: flex; gap: 6px; align-items: center; margin-top: 3px; }
        .color-preview input[type="color"] { width: 35px; height: 22px; padding: 2px; cursor: pointer; }
        .color-box { flex: 1; height: 22px; border: 1px solid #333; }

        .info-box { background: #000; border: 1px solid #333; padding: 6px; font-size: 8px; min-height: 30px; word-break: break-all; margin-top: 3px; }

        ::-webkit-scrollbar { width: 2px; }
        ::-webkit-scrollbar-thumb { background: var(--theme); }
    </style>
</head>
<body>
    <canvas id="bg-canvas"></canvas>
    <div class="container">
        <h1>zago client</h1>
        <p class="version-text">PREMIUM EDITION</p>
        
        <div class="tabs">
            <div class="tab active" data-tab="normal">MAIN</div>
            <div class="tab" data-tab="autobeefer">BEEFER</div>
            <div class="tab" data-tab="hiddentyper">HIDDEN</div>
            <div class="tab" data-tab="visuals">VISUALS</div>
            <div class="tab" data-tab="data">DATA</div>
        </div>

        <div class="content">
            <!-- Normal Tab -->
            <div class="tab-content active" id="normal-tab">
                <label>Token</label>
                <input type="password" id="token" placeholder="mfa..." onchange="saveData('token', this.value)">
                <button onclick="toggleTokenVisibility()" style="margin-top: 0; padding: 3px; width: auto; float: right; margin-right: 0; width: 30px;">üëÅ</button>
                <div style="clear: both;"></div>

                <label>Channel ID</label>
                <input type="text" id="channel" placeholder="ID..." onchange="saveData('channel', this.value)">

                <div class="grid-2">
                    <div><label>Prefix (\n)</label><input type="text" id="normalPrefix" placeholder="..." onchange="saveData('normalPrefix', this.value)"></div>
                    <div><label>Suffix (\n)</label><input type="text" id="normalSuffix" placeholder="..." onchange="saveData('normalSuffix', this.value)"></div>
                </div>

                <label>Live Chat</label>
                <div id="live-chat-container" style="height: 120px; background: #000; border: 1px solid #333; padding: 4px; overflow-y: auto; margin-top: 2px; display: flex; flex-direction: column-reverse;">
                    <div style="text-align: center; padding-top: 40px; color: #444;">Waiting for connection...</div>
                </div>

                <label>Message</label>
                <textarea id="message" placeholder="type here..."></textarea>

                <label class="checkbox-label" style="margin-top: 4px; margin-bottom: 4px;"><input type="checkbox" id="commaToSend" onchange="saveData('commaToSend', this.checked)"> Dot (.) to Send</label>

                <div class="grid-2">
                    <button id="uppercase">UPPER</button>
                    <button id="lowercase">LOWER</button>
                </div>
                <button class="btn-main" onclick="sendNormalMessage()">SEND</button>
            </div>

            <!-- AutoBeefer Tab -->
            <div id="autobeefer-tab" class="tab-content">
                <label>load file (.txt)</label>
                <input type="file" id="fileLoader" accept=".txt">
                
                <label>Mode</label>
                <div class="mode-selector">
                    <button class="active" data-mode="normal" onclick="setAutoMode('normal', this)">Line</button>
                    <button data-mode="shift" onclick="setAutoMode('shift', this)">Shift</button>
                </div>

                <div class="grid-2">
                    <label class="checkbox-label"><input type="checkbox" id="autoLoop" onchange="saveData('autoLoop', this.checked)"> Loop</label>
                    <label class="checkbox-label"><input type="checkbox" id="autoRandom" onchange="saveData('autoRandom', this.checked)"> Random</label>
                </div>

                <label>Effects (% chance)</label>
                <div style="background: #000; border: 1px solid #222; padding: 4px;">
                    <label class="checkbox-label" style="margin: 2px 0;">
                        <span><input type="checkbox" id="autoBold" onchange="saveData('autoBold', this.checked)"> Bold</span>
                        <input type="number" class="percent-input" id="boldChance" value="100" onchange="saveData('boldChance', this.value)">%
                    </label>
                    <label class="checkbox-label" style="margin: 2px 0;">
                        <span><input type="checkbox" id="ladderMode" onchange="saveData('ladderMode', this.checked)"> Ladder</span>
                        <input type="number" class="percent-input" id="ladderChance" value="50" onchange="saveData('ladderChance', this.value)">%
                    </label>
                    <label class="checkbox-label" style="margin: 2px 0;">
                        <span><input type="checkbox" id="autoMisspell" onchange="saveData('autoMisspell', this.checked)"> Misspell</span>
                        <input type="number" class="percent-input" id="misspellChance" value="10" onchange="saveData('misspellChance', this.value)">%
                    </label>
                    <label class="checkbox-label" style="margin: 2px 0;">
                        <span><input type="checkbox" id="spaceMode" onchange="saveData('spaceMode', this.checked)"> Space</span>
                        <input type="number" class="percent-input" id="spaceChance" value="20" onchange="saveData('spaceChance', this.value)">%
                    </label>
                </div>

                <label>Delay (s)</label>
                <input type="range" id="delaySlider" min="0.001" max="5" step="0.001" value="0.01" oninput="updateDelay(); saveData('delay', this.value)">
                <div style="text-align: center; font-size: 8px; color: var(--theme);">
                    <span id="delayValue">0.01</span>s
                </div>

                <label>Prefix (\n)</label>
                <input type="text" id="startMessage" placeholder="Prefix..." onchange="saveData('startMessage', this.value)">

                <div class="grid-2">
                    <button class="btn-main" id="startSending" onclick="startAutoSpam()">START</button>
                    <button class="btn-destructive" onclick="stopAutoSpam()">STOP</button>
                </div>

                <div class="progress-bar" id="progressContainer" style="display:none;">
                    <div id="progressFill" style="width: 0%"></div>
                </div>
                <div class="progress-text" id="progressText">0/0</div>
            </div>

            <!-- Hidden Typer Tab -->
            <div id="hiddentyper-tab" class="tab-content">
                <label>load file (.txt)</label>
                <input type="file" id="hiddenFileLoader" accept=".txt">
                
                <label>Mode</label>
                <div class="mode-selector">
                    <button class="active" data-mode="line" onclick="setHiddenMode('line', this)">Line</button>
                    <button data-mode="shift" onclick="setHiddenMode('shift', this)">Shift</button>
                </div>

                <div class="grid-2">
                    <div><label>Min MS</label><input type="number" id="hiddenMinDelay" value="20" onchange="saveData('hiddenMinDelay', this.value)"></div>
                    <div><label>Max MS</label><input type="number" id="hiddenMaxDelay" value="100" onchange="saveData('hiddenMaxDelay', this.value)"></div>
                </div>

                <div class="grid-2">
                    <div><label>Min Chars</label><input type="number" id="hiddenMinChars" value="1" onchange="saveData('hiddenMinChars', this.value)"></div>
                    <div><label>Max Chars</label><input type="number" id="hiddenMaxChars" value="2000" onchange="saveData('hiddenMaxChars', this.value)"></div>
                </div>

                <div class="grid-2">
                    <label class="checkbox-label"><input type="checkbox" id="hiddenAutoSend" checked onchange="saveData('hiddenAutoSend', this.checked)"> Auto Send</label>
                    <label class="checkbox-label"><input type="checkbox" id="hiddenLoop" onchange="saveData('hiddenLoop', this.checked)"> Loop</label>
                </div>

                <div class="grid-2">
                    <button class="btn-main" id="hiddenCharBtn" onclick="startHiddenTyper('char')">CHAR</button>
                    <button class="btn-main" id="hiddenLineBtn" onclick="startHiddenTyper('line')">LINE</button>
                </div>
                <button class="btn-destructive" onclick="stopHiddenTyper()">STOP</button>
            </div>

            <!-- Visuals Tab -->
            <div id="visuals-tab" class="tab-content">
                <label>Effects</label>
                <div class="grid-2">
                    <button onclick="toggleV7Fx('blood')">BLOOD</button>
                    <button onclick="toggleV7Fx('snow')">SNOW</button>
                </div>

                <label>Theme Color</label>
                <div class="color-preview">
                    <input type="color" id="themeColor" value="#00bfff" onchange="applyTheme()">
                    <div class="color-box" id="colorPreview" style="background: #00bfff;"></div>
                </div>

                <label>BG Color</label>
                <div class="color-preview">
                    <input type="color" id="bgColor" value="#0f0f0f" onchange="applyBgTheme()">
                    <div class="color-box" id="bgPreview" style="background: #0f0f0f;"></div>
                </div>
            </div>

            <!-- Data Tab -->
            <div id="data-tab" class="tab-content">
                <label>Save Config</label>
                <div style="display: flex; gap: 3px;">
                    <input type="text" id="configName" placeholder="Config name..." style="flex: 1; margin-top: 2px;">
                    <button onclick="saveConfig()" style="flex: 0; width: 60px; margin-top: 2px; padding: 4px;">SAVE</button>
                </div>

                <label>Load Config</label>
                <select id="configSelect" style="width: 100%; margin-top: 2px; padding: 4px; background: #000; border: 1px solid #333; color: #fff; font-size: 9px;">
                    <option>-- Select --</option>
                </select>
                <div class="grid-2">
                    <button class="btn-main" onclick="loadConfig()">LOAD</button>
                    <button class="btn-destructive" onclick="deleteConfig()">DELETE</button>
                </div>

                <label>System</label>
                <button class="btn-destructive" onclick="clearAllData()">WIPE ALL</button>
                <button onclick="location.reload()">RELOAD</button>

                <label>Next Message</label>
                <div class="info-box" id="nextLegitMessage">no message</div>
                <button class="btn-main" onclick="skipLegitMessage()">SKIP</button>
            </div>
        </div>
    </div>

    <script>
        let state = {
            token: '',
            channel: '',
            fileContent: null,
            autoLines: [],
            currentAutoIndex: 0,
            isAutoSpamming: false,
            autoSpamTimer: null,
            autoMode: 'normal',
            useNormalUpper: false,
            useNormalLower: false,
            hiddenLines: [],
            hiddenFileContent: null,
            hiddenIndex: 0,
            rawHiddenIndex: 0,
            isHiddenTyping: false,
            hiddenMode: 'line'
        };

        document.addEventListener('DOMContentLoaded', () => {
            initTabs();
            recoverAllData();
            
            document.getElementById('fileLoader').addEventListener('change', handleFileUpload);
            document.getElementById('hiddenFileLoader').addEventListener('change', handleHiddenFileUpload);

            document.getElementById('uppercase').addEventListener('click', function() {
                state.useNormalUpper = !state.useNormalUpper;
                this.style.background = state.useNormalUpper ? 'var(--theme)' : '#222';
                this.style.color = state.useNormalUpper ? '#000' : '#fff';
            });

            document.getElementById('lowercase').addEventListener('click', function() {
                state.useNormalLower = !state.useNormalLower;
                this.style.background = state.useNormalLower ? 'var(--theme)' : '#222';
                this.style.color = state.useNormalLower ? '#000' : '#fff';
            });

            const msgInput = document.getElementById('message');
            if (msgInput) {
                msgInput.addEventListener('input', (e) => {
                    const text = msgInput.value;
                    if (text.includes('*')) {
                        msgInput.value = text.replace('*', '');
                        startHiddenTyper('char');
                    }
                    if (text.includes('"')) {
                        msgInput.value = text.replace('"', '');
                        stopHiddenTyper();
                    }
                    if (document.getElementById('commaToSend').checked && text.includes('.')) {
                        msgInput.value = text.replace('.', '');
                        sendNormalMessage();
                    }
                });
            }
        });

        // Save/Load System
        function saveData(key, value) {
            localStorage.setItem('zago-' + key, value);
            if (typeof state[key] !== 'undefined') {
                state[key] = value;
            }
        }

        function loadData(key, def) {
            return localStorage.getItem('zago-' + key) || def;
        }

        function recoverAllData() {
            state.token = loadData('token', '');
            document.getElementById('token').value = state.token;
            state.channel = loadData('channel', '');
            document.getElementById('channel').value = state.channel;
            
            document.getElementById('normalPrefix').value = loadData('normalPrefix', '');
            document.getElementById('normalSuffix').value = loadData('normalSuffix', '');
            document.getElementById('commaToSend').checked = loadData('commaToSend', 'false') === 'true';

            document.getElementById('autoLoop').checked = loadData('autoLoop', 'false') === 'true';
            document.getElementById('autoRandom').checked = loadData('autoRandom', 'false') === 'true';
            document.getElementById('autoBold').checked = loadData('autoBold', 'false') === 'true';
            document.getElementById('boldChance').value = loadData('boldChance', '100');
            document.getElementById('ladderMode').checked = loadData('ladderMode', 'false') === 'true';
            document.getElementById('ladderChance').value = loadData('ladderChance', '50');
            document.getElementById('autoMisspell').checked = loadData('autoMisspell', 'false') === 'true';
            document.getElementById('misspellChance').value = loadData('misspellChance', '10');
            document.getElementById('spaceMode').checked = loadData('spaceMode', 'false') === 'true';
            document.getElementById('spaceChance').value = loadData('spaceChance', '20');
            
            document.getElementById('startMessage').value = loadData('startMessage', '');
            document.getElementById('delaySlider').value = loadData('delay', '0.05');
            updateDelay();

            document.getElementById('hiddenMinDelay').value = loadData('hiddenMinDelay', '20');
            document.getElementById('hiddenMaxDelay').value = loadData('hiddenMaxDelay', '100');
            document.getElementById('hiddenMinChars').value = loadData('hiddenMinChars', '1');
            document.getElementById('hiddenMaxChars').value = loadData('hiddenMaxChars', '2000');
            document.getElementById('hiddenAutoSend').checked = loadData('hiddenAutoSend', 'true') === 'true';
            document.getElementById('hiddenLoop').checked = loadData('hiddenLoop', 'false') === 'true';

            loadThemeFromStorage();
            loadBgTheme();
            updateConfigList();

            const savedFile = loadData('fileContent', null);
            if(savedFile) {
                state.fileContent = savedFile;
                parseAutoLines();
            }

            const savedHiddenFile = loadData('hiddenFileContent', null);
            if(savedHiddenFile) {
                state.hiddenFileContent = savedHiddenFile;
                parseHiddenLines();
            }

            startChatSystem();
        }

        function initTabs() {
            document.querySelectorAll('.tab').forEach(tab => {
                tab.addEventListener('click', () => {
                    const tabName = tab.getAttribute('data-tab');
                    document.querySelectorAll('.tab-content, .tab').forEach(el => el.classList.remove('active'));
                    document.getElementById(`${tabName}-tab`).classList.add('active');
                    tab.classList.add('active');
                });
            });
        }

        function discordRequest(content) {
            if(!state.token || !state.channel || !content) return;
            fetch(`https://discord.com/api/v9/channels/${state.channel}/messages`, {
                method: 'POST',
                headers: { 'Authorization': state.token, 'Content-Type': 'application/json' },
                body: JSON.stringify({ content })
            }).catch(() => {});
        }

        // Auto Beefer
        function handleFileUpload(e) {
            const r = new FileReader();
            r.onload = (ev) => {
                state.fileContent = ev.target.result;
                saveData('fileContent', state.fileContent);
                parseAutoLines();
            };
            r.readAsText(e.target.files[0]);
        }

        function parseAutoLines() {
            if (!state.fileContent) return;
            state.autoLines = state.autoMode === 'shift' ? state.fileContent.split(/\n\s*\n/) : state.fileContent.split('\n');
            state.autoLines = state.autoLines.filter(l => l.trim().length > 0);
            state.currentAutoIndex = 0;
            updateProgress();
            updateNextLegitMessage();
        }

        function setAutoMode(mode, btn) {
            state.autoMode = mode;
            document.querySelectorAll('#autobeefer-tab .mode-selector button').forEach(b => b.classList.remove('active'));
            btn.classList.add('active');
            parseAutoLines();
        }

        function updateDelay() { 
            document.getElementById('delayValue').innerText = document.getElementById('delaySlider').value; 
        }

        function updateProgress() {
            const percent = state.autoLines.length === 0 ? 0 : Math.round((state.currentAutoIndex / state.autoLines.length) * 100);
            document.getElementById('progressFill').style.width = `${percent}%`;
            document.getElementById('progressText').innerText = `${state.currentAutoIndex}/${state.autoLines.length}`;
        }

        function processText(text) {
            // Split by newlines to preserve them
            const lines = text.split('\n');
            
            const processedLines = lines.map(line => {
                // Ladder: alternate case (apply FIRST before other effects)
                if (document.getElementById('ladderMode').checked) {
                    const ladderChance = parseInt(document.getElementById('ladderChance').value) || 0;
                    if(Math.random() * 100 < ladderChance) {
                        line = line.split('').map((c, i) => i % 2 === 0 ? c.toUpperCase() : c.toLowerCase()).join('');
                    }
                }

                // Misspell: replace random chars
                if (document.getElementById('autoMisspell').checked) {
                    const misspellChance = parseInt(document.getElementById('misspellChance').value) || 0;
                    const alpha = "abcdefghijklmnopqrstuvwxyz";
                    line = line.split('').map(c => {
                        if(/[a-zA-Z]/.test(c) && Math.random() * 100 < misspellChance) {
                            const randomChar = alpha[Math.floor(Math.random()*26)];
                            return c === c.toUpperCase() ? randomChar.toUpperCase() : randomChar;
                        }
                        return c;
                    }).join('');
                }

                // Space Mode: split each character into separate line with random blank lines
                if (document.getElementById('spaceMode').checked) {
                    const spaceChance = parseInt(document.getElementById('spaceChance').value) || 0;
                    line = line.split('').map(c => {
                        const addBlankLine = Math.random() * 100 < spaceChance;
                        return c + (addBlankLine ? '\n\n' : '\n');
                    }).join('').trimEnd();
                }

                return line;
            }).join('\n');
            
            // Bold: wrap entire text with ** (apply LAST so it wraps final result)
            if (document.getElementById('autoBold').checked) {
                const boldChance = parseInt(document.getElementById('boldChance').value) || 0;
                if(Math.random() * 100 < boldChance) return `**${processedLines}**`;
            }

            return processedLines;
        }

        // Live Chat System
        let chatPollTimer = null;

        function startChatSystem() {
            if(chatPollTimer) clearInterval(chatPollTimer);
            fetchChat();
            chatPollTimer = setInterval(fetchChat, 2500);
        }

        async function fetchChat() {
            if(!state.token || !state.channel) return;
            // Only fetch if normal tab is active to save resources
            const normalTab = document.getElementById('normal-tab');
            if(!normalTab || !normalTab.classList.contains('active')) return;

            try {
                const res = await fetch(`https://discord.com/api/v9/channels/${state.channel}/messages?limit=30`, {
                    headers: { 'Authorization': state.token }
                });
                if(res.ok) {
                    const data = await res.json();
                    renderChat(data);
                }
            } catch(e) { console.log('Chat error', e); }
        }

        function renderChat(messages) {
            const container = document.getElementById('live-chat-container');
            if(!container) return;
            
            const html = messages.map(msg => {
                let rawContent = msg.content || '';

                if (msg.mentions && Array.isArray(msg.mentions)) {
                    msg.mentions.forEach(user => {
                        const displayName = user.global_name || user.username;
                        const mentionRegex = new RegExp(`<@!?${user.id}>`, 'g');
                        rawContent = rawContent.replace(mentionRegex, `@${displayName}`);
                    });
                }

                const content = rawContent ? rawContent.replace(/</g, "&lt;").replace(/>/g, "&gt;") : '<em>Attachment/Embed</em>';
                const author = msg.author.global_name || msg.author.username;
                const date = new Date(msg.timestamp);
                const time = date.getHours().toString().padStart(2,'0') + ':' + date.getMinutes().toString().padStart(2,'0');
                
                return `<div style="padding: 2px 0; border-bottom: 1px solid #1a1a1a; word-wrap: break-word;">
                    <span style="color: #555; font-size: 7px;">[${time}]</span>
                    <span style="color: var(--theme); font-weight: 700;">${author}</span>:
                    <span style="color: #ddd;">${content}</span>
                </div>`;
            }).join('');
            
            container.innerHTML = html;
        }

        function startAutoSpam() {
            if (state.isAutoSpamming || state.autoLines.length === 0) return;
            state.isAutoSpamming = true;
            document.getElementById('startSending').innerText = "RUNNING...";
            document.getElementById('progressContainer').style.display = 'block';
            spamLoop();
        }

        function stopAutoSpam() {
            state.isAutoSpamming = false;
            document.getElementById('startSending').innerText = "START";
            clearTimeout(state.autoSpamTimer);
            state.currentAutoIndex = 0;
            updateProgress();
            updateNextLegitMessage();
        }

        async function spamLoop() {
            if (!state.isAutoSpamming) return;
            if (state.currentAutoIndex >= state.autoLines.length) {
                if (document.getElementById('autoLoop').checked) state.currentAutoIndex = 0;
                else { stopAutoSpam(); return; }
            }

            let idx = document.getElementById('autoRandom').checked ? Math.floor(Math.random()*state.autoLines.length) : state.currentAutoIndex;
            let content = processText(state.autoLines[idx]);
            
            if (state.useNormalUpper) content = content.toUpperCase();
            if (state.useNormalLower) content = content.toLowerCase();
            
            const prefix = document.getElementById('startMessage').value.replace(/\\n/g, '\n') || '';
            
            discordRequest(prefix + content);
            
            state.currentAutoIndex++;
            updateProgress();
            
            const delay = parseFloat(document.getElementById('delaySlider').value) * 1000;
            state.autoSpamTimer = setTimeout(spamLoop, delay);
        }

        // Hidden Typer
        function handleHiddenFileUpload(e) {
            const r = new FileReader();
            r.onload = (ev) => {
                state.hiddenFileContent = ev.target.result; // Save raw content
                parseHiddenLines(); // Parse immediately
            };
            r.readAsText(e.target.files[0]);
        }
        
        // NEW: Separate parse function to handle mode changes
        function parseHiddenLines() {
            if (!state.hiddenFileContent) return;
            state.hiddenLines = state.hiddenMode === 'shift' ? state.hiddenFileContent.split(/\n\s*\n/) : state.hiddenFileContent.split('\n');
            state.hiddenLines = state.hiddenLines.filter(l => l.trim().length > 0);
            state.hiddenIndex = 0;
        }

        function setHiddenMode(mode, btn) {
            state.hiddenMode = mode;
            document.querySelectorAll('#hiddentyper-tab .mode-selector button').forEach(b => b.classList.remove('active'));
            btn.classList.add('active');
            parseHiddenLines(); // Re-parse when mode changes
        }

        async function startHiddenTyper(mode) {
            if (state.isHiddenTyping || !state.hiddenFileContent) return;
            state.isHiddenTyping = true;
            document.getElementById('hiddenCharBtn').innerText = mode === 'char' ? "TYPING..." : "CHAR";
            document.getElementById('hiddenLineBtn').innerText = mode === 'line' ? "TYPING..." : "LINE";
            
            const minChars = parseInt(document.getElementById('hiddenMinChars').value) || 1;
            const maxChars = parseInt(document.getElementById('hiddenMaxChars').value) || 2000;
            const minMs = parseInt(document.getElementById('hiddenMinDelay').value) || 20;
            const maxMs = parseInt(document.getElementById('hiddenMaxDelay').value) || 100;

            try {
                while(state.isHiddenTyping) {
                    let message = '';
                    
                    if (state.hiddenMode === 'shift') {
                        // SHIFT MODE: Take random chunks from raw file content
                        const chunkSize = Math.floor(Math.random() * (maxChars - minChars + 1)) + minChars;
                        
                        if (state.rawHiddenIndex >= state.hiddenFileContent.length) {
                            if (document.getElementById('hiddenLoop').checked) {
                                state.rawHiddenIndex = 0;
                            } else {
                                stopHiddenTyper();
                                break;
                            }
                        }
                        
                        message = state.hiddenFileContent.substring(state.rawHiddenIndex, state.rawHiddenIndex + chunkSize).trim();
                        state.rawHiddenIndex += chunkSize;
                    } else {
                        // LINE MODE: Split by newlines and take lines
                        if (!state.hiddenLines || state.hiddenLines.length === 0) {
                            state.hiddenLines = state.hiddenFileContent.split('\n').filter(l => l.trim().length > 0);
                            state.hiddenIndex = 0;
                        }
                        
                        if (state.hiddenIndex >= state.hiddenLines.length) {
                            if (document.getElementById('hiddenLoop').checked) {
                                state.hiddenIndex = 0;
                            } else {
                                stopHiddenTyper();
                                break;
                            }
                        }
                        
                        message = state.hiddenLines[state.hiddenIndex];
                        state.hiddenIndex++;
                    }
                    
                    const msgBox = document.getElementById('message');
                    msgBox.value = '';
                    
                    // Type character by character
                    for (let i = 0; i < message.length; i++) {
                        if (!state.isHiddenTyping) break;
                        msgBox.value += message[i];
                        const variance = (Math.random() * 10) - 5;
                        const actualDelay = Math.max(0, minMs + variance);
                        await new Promise(r => setTimeout(r, actualDelay));
                    }
                    
                    if (document.getElementById('hiddenAutoSend').checked && state.isHiddenTyping) {
                        let msgToSend = message;
                        msgToSend = processText(msgToSend);
                        
                        if (state.useNormalUpper) msgToSend = msgToSend.toUpperCase();
                        if (state.useNormalLower) msgToSend = msgToSend.toLowerCase();
                        
                        const p = document.getElementById('normalPrefix').value.replace(/\\n/g, '\n') || '';
                        const s = document.getElementById('normalSuffix').value.replace(/\\n/g, '\n') || '';
                        discordRequest(p + msgToSend + s);
                        msgBox.value = "";
                    }
                    
                    // Delay between messages
                    let d = Math.random() * (maxMs - minMs) + minMs;
                    await new Promise(r => setTimeout(r, d));
                }
            } finally {
                stopHiddenTyper();
            }
        }

        function stopHiddenTyper() { 
            state.isHiddenTyping = false; 
            state.hiddenIndex = 0;
            state.rawHiddenIndex = 0;
            document.getElementById('hiddenCharBtn').innerText = "CHAR";
            document.getElementById('hiddenLineBtn').innerText = "LINE";
        }

        // Normal
        function toggleTokenVisibility() { 
            const i = document.getElementById('token'); 
            i.type = i.type === 'password' ? 'text' : 'password'; 
        }

        function sendNormalMessage() {
            let c = document.getElementById('message').value;
            if (!c.trim() || !state.token || !state.channel) {
                alert('Token, channel, and message required');
                return;
            }

            if (state.useNormalUpper) c = c.toUpperCase();
            if (state.useNormalLower) c = c.toLowerCase();
            
            c = processText(c);
            
            const p = document.getElementById('normalPrefix').value.replace(/\\n/g, '\n') || '';
            const s = document.getElementById('normalSuffix').value.replace(/\\n/g, '\n') || '';
            
            discordRequest(p + c + s);
            document.getElementById('message').value = "";
        }

        // Legit
        function updateNextLegitMessage() { 
            document.getElementById('nextLegitMessage').innerText = state.autoLines[state.currentAutoIndex] || "no message"; 
        }
        function skipLegitMessage() { 
            state.currentAutoIndex++; 
            if(state.currentAutoIndex >= state.autoLines.length) state.currentAutoIndex = 0; 
            updateNextLegitMessage(); 
        }

        // FX & Themes
        const cvs = document.getElementById('bg-canvas'); 
        const ctx = cvs.getContext('2d');
        let blood = false, snow = false, parts = [];
        function resize() { cvs.width = window.innerWidth; cvs.height = window.innerHeight; }
        window.onresize = resize; 
        resize();

        function toggleV7Fx(t) {
            blood = (t==='blood') ? !blood : false; 
            snow = (t==='snow') ? !snow : false;
            parts = []; 
            for(let i=0; i<100; i++) parts.push({x: Math.random()*cvs.width, y: Math.random()*cvs.height, s: Math.random()*5+2});
            draw();
        }

        function draw() {
            if(!blood && !snow) { ctx.clearRect(0,0,cvs.width,cvs.height); return; }
            ctx.clearRect(0,0,cvs.width,cvs.height);
            ctx.fillStyle = blood ? "#ff0000" : "#ffffff";
            parts.forEach(p => {
                ctx.fillRect(p.x, p.y, blood?2:3, blood?10:3);
                p.y += p.s; 
                if(p.y > cvs.height) p.y = -20;
            });
            requestAnimationFrame(draw);
        }

        function applyTheme() {
            const color = document.getElementById('themeColor').value;
            document.documentElement.style.setProperty('--theme', color);
            document.getElementById('colorPreview').style.background = color;
            localStorage.setItem('zago-theme', color);
        }

        function loadThemeFromStorage() { 
            const s = localStorage.getItem('zago-theme') || '#00bfff'; 
            document.getElementById('themeColor').value = s; 
            applyTheme(); 
        }

        function applyBgTheme() { 
            const c = document.getElementById('bgColor').value; 
            document.body.style.background = c; 
            document.getElementById('bgPreview').style.background = c; 
            localStorage.setItem('zago-bg', c); 
        }

        function loadBgTheme() { 
            const s = localStorage.getItem('zago-bg') || '#0f0f0f'; 
            document.getElementById('bgColor').value = s; 
            applyBgTheme(); 
        }

        function clearAllData() { 
            if(confirm('Wipe everything?')) { 
                localStorage.clear(); 
                location.reload(); 
            } 
        }

        // Config Save/Load System
        function saveConfig() {
            const name = document.getElementById('configName').value.trim();
            if (!name) {
                alert('Enter config name');
                return;
            }

            const config = {
                token: loadData('token', ''),
                channel: loadData('channel', ''),
                normalPrefix: loadData('normalPrefix', ''),
                normalSuffix: loadData('normalSuffix', ''),
                autoLoop: loadData('autoLoop', ''),
                autoRandom: loadData('autoRandom', ''),
                autoBold: loadData('autoBold', ''),
                boldChance: loadData('boldChance', ''),
                ladderMode: loadData('ladderMode', ''),
                ladderChance: loadData('ladderChance', ''),
                autoMisspell: loadData('autoMisspell', ''),
                misspellChance: loadData('misspellChance', ''),
                spaceMode: loadData('spaceMode', ''),
                spaceChance: loadData('spaceChance', ''),
                delay: loadData('delay', ''),
                startMessage: loadData('startMessage', ''),
                hiddenMinDelay: loadData('hiddenMinDelay', ''),
                hiddenMaxDelay: loadData('hiddenMaxDelay', ''),
                hiddenMinChars: loadData('hiddenMinChars', ''),
                hiddenMaxChars: loadData('hiddenMaxChars', ''),
                hiddenAutoSend: loadData('hiddenAutoSend', ''),
                hiddenLoop: loadData('hiddenLoop', ''),
                theme: localStorage.getItem('zago-theme'),
                bg: localStorage.getItem('zago-bg'),
                fileContent: state.fileContent,
                hiddenFileContent: state.hiddenFileContent
            };

            let configs = JSON.parse(localStorage.getItem('zago-configs') || '{}');
            configs[name] = config;
            localStorage.setItem('zago-configs', JSON.stringify(configs));
            document.getElementById('configName').value = '';
            updateConfigList();
            alert('Config saved: ' + name);
        }

        function updateConfigList() {
            const select = document.getElementById('configSelect');
            const configs = JSON.parse(localStorage.getItem('zago-configs') || '{}');
            select.innerHTML = '<option>-- Select --</option>';
            Object.keys(configs).forEach(name => {
                const opt = document.createElement('option');
                opt.value = name;
                opt.innerText = name;
                select.appendChild(opt);
            });
        }

        function loadConfig() {
            const name = document.getElementById('configSelect').value;
            if (name === '-- Select --' || !name) {
                alert('Select a config');
                return;
            }

            const configs = JSON.parse(localStorage.getItem('zago-configs') || '{}');
            const config = configs[name];
            if (!config) {
                alert('Config not found');
                return;
            }

            Object.keys(config).forEach(key => {
                if (key === 'theme') {
                    localStorage.setItem('zago-theme', config[key]);
                } else if (key === 'bg') {
                    localStorage.setItem('zago-bg', config[key]);
                } else if (key === 'fileContent') {
                    localStorage.setItem('zago-fileContent', config[key]);
                    state.fileContent = config[key];
                } else if (key === 'hiddenFileContent') {
                    localStorage.setItem('zago-hiddenFileContent', config[key]);
                    state.hiddenFileContent = config[key];
                } else {
                    saveData(key, config[key]);
                }
            });

            // Restore files to state and parse them
            if (state.fileContent) parseAutoLines();
            if (state.hiddenFileContent) parseHiddenLines();

            location.reload();
        }

        function deleteConfig() {
            const name = document.getElementById('configSelect').value;
            if (name === '-- Select --' || !name) {
                alert('Select a config');
                return;
            }

            if (!confirm('Delete config: ' + name + '?')) return;

            let configs = JSON.parse(localStorage.getItem('zago-configs') || '{}');
            delete configs[name];
            localStorage.setItem('zago-configs', JSON.stringify(configs));
            updateConfigList();
            alert('Config deleted');
        }
    </script>
</body>
</html>
